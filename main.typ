#let indent = 2em
#let no-indent(body) = {
    set par(first-line-indent: 0em)
    [#body]
    set par(first-line-indent: indent)
}
#set text(lang: "ru")
#set page(numbering: "1")
#set par(
  first-line-indent: indent,
  justify: true,
)
#show par: set block(spacing: 0.65em)

= Сигналы в Linux
Никитин Богдан, M3236
= Введение

_Сигнал_ - это уведомление для процесса о том, что произошло событие. Сигналы иногда описываются как _программные прерывания_. Сигналы аналогичны аппаратным прерываниям в том смысле, что они прерывают нормальный ход выполнения программы, и в большинстве случаев невозможно точно предсказать, когда сигнал поступит.

Один процесс может (если у него есть подходящие разрешения) отправлять сигнал другому процессу. В этом случае сигналы могут использоваться в качестве техники синхронизации или даже как примитивной формы межпроцессного взаимодействия (IPC). Также возможно отправление процессом сигнала самому себе. Однако обычным источником многих сигналов, отправляемых процессу, является ядро. Среди типов событий, вызывающих генерацию ядром сигнала для процесса, могут быть следующие:

- Произошло аппаратное исключение, что означает, что аппаратное обеспечение зафиксировало неверное состояние и оповестила об этом ядро, которое в свою очередь отправило соответствующий сигнал затронутому процессу. Примерами аппаратного исключения могут быть выполнение ошибочной машинной инструкции, деление на 0 или обращение к недоступному участку памяти.

- Пользователь ввел один из специальных символов терминала, которые генерируют сигналы. К таким символам относятся символ _прерывания_ (обычно `Control-C`) и символ _приостановки_ (обычно `Control-Z`).

- Произошло программное событие. Например, появился ввод на файловом дескрипторе, изменен размер окна терминала, сработал таймер, превышено временное ограничение ЦП или завершился дочерний процесс.

Каждый сигнал определен как целое число. Фактические числа, используемые для каждого сигнала, различаются в различных реализациях, поэтому в программах используются соотвествующие константы с именами вида `SIGxxx`, определённые в `<signal.h>` (как и все функции, использующиеся при работе с сигналами). Например, когда пользователь вводит символ _прерывания_, сигнал `SIGINT` (номер сигнала 2) поступает в процесс.

Сигналы делятся на две большие категории. Первый набор составляют _традиционные_ или _стандартные_ сигналы, которые используются ядром для уведомления процессов о событиях. На Linux стандартные сигналы нумеруются от 1 до 31. Другой набор сигналов состоит из сигналов _реального времени_, которые будут описаны позже.

Ядро различает две разные фазы, связанные с передачей сигнала:

#no-indent[*Генерация сигнала*]

Ядро обновляет структуру данных процесса-получателя, чтобы отразить тот факт, что новый сигнал был отправлен.

#no-indent[*Доставка сигнала*]

Ядро заставляет процесс-получатель реагировать на сигнал, изменяя его состояние выполнения, начиная выполнение указанного обработчика сигнала или и того, и другого.

#v(1em)

Каждый сгенерированный сигнал может быть доставлен не более одного раза. Сигналы являются потребляемыми ресурсами: после их доставки отменяется вся информация о дескрипторе процесса, которая относится к их предыдущему существованию.

= Ожидающие сигналы и маска сигналов

Сигнал может быть _заблокирован_, что означает, что он не будет доставлен, пока его позже не разблокируют. Между моментом его генерации и моментом доставки сигнала говорят, что сигнал в _состоянии ожидания_.

У каждого потока в процессе есть независимая маска сигналов, которая указывает набор сигналов, которые в данный момент заблокированы для потока. Поток может управлять своей маской сигналов, используя `pthread_sigmask`. В традиционном однопоточном приложении можно использовать `sigprocmask` для управления маской сигналов.

Дочерний процесс, созданный с помощью `fork`, наследует копию маски сигналов своего родителя; маска сигналов сохраняется при использовании `execve`.

Сигнал может быть сгенерирован (а значит и стать ожидающим) как для всего процесса (например, при отправке с помощью `kill`) так и для отдельного потока (например, некоторые сигналы, такие как `SIGSEGV` и `SIGFPE`, сгенерированные в следствии выполнения определённой инструкции на машинном языке в самом потоке, или сигналы, направленные определённому потоку с помощью `pthread_kill`). Направленный процессу сигнал может быть доставлен в любой из потоков, у которых сигнал не заблокирован. Если имеется несколько таких потоков, то ядро выбирает произвольный поток, которой и доставит сигнал.

Поток может получить набор сигналов, которые в данный момент находятся в состоянии ожидания, используя вызов `sigpending`. Этот набор будет состоять из объединения набора ожидающих сигналов, направленных процессу, и набора ожидающих сигналов для вызвавшего потока.

Потомок, созданный с помощью `fork`, изначально имеет пустой набор ожидающих сигналов; набор ожидающих сигналов сохраняется при использовании `execve`.

= Диспозиция сигналов
Каждый сигнал имеет текущий _обработчик_, который определяет, что будет делать процесс при поступлении сигнала.

В таблицах далее есть столбец «Действие», в котором указан обработчик по умолчанию для каждого сигнала:

#no-indent[*Term*]

Процесс завершается (убивается).

#no-indent[*Ign*] 

Сигнал игнорируется.

#no-indent[*Core*]

Процесс завершается (убивается), и, если возможно, создается файл ядра, содержащий его контекст выполнения; этот файл может использоваться в целях отладки.

#no-indent[*Stop*] 

Процесс останавливается

#no-indent[*Cont*] 

Если процесс был остановлен, его выполнение возобновляется

#v(1em)

Процесс может изменить обработчик сигнала с помощью `sigaction` или `signal` (второй вызов менее портируемый на другие системы, поэтому рекомендуется использовать первый). Используя данные системные вызовы процесс может выбрать одно из следующих действий при получении сигнала: выполнить действие по умолчанию, игнорировать сигнал, поймать сигнал обработчиком сигнала — функцией, задаваемой программистом, которая автоматически вызывается при получении сигнала (по умолчанию обработчик сигнала использует обычный стек процесса. Возможно сделать так, чтобы обработчик сигнала использовал альтернативный стек; это делается с помощью `sigaltstack` и может быть полезно при обработке сигнала `SIGSEGV`, который возникает при нехватке свободного места в обычном стеке процесса).

Реакция на сигналы является атрибутом процесса: в многопоточном приложении реакция на определённый сигнал одинакова для всех потоков.

Потомок, созданный с помощью `fork`, наследует реакцию на сигналы от своего родителя. При `execve` реакция на сигналы устанавливается в значение по умолчанию; реакция на игнорируемые сигналы не изменяется.

= Отправка сигнала
Для отправки сигнала можно использовать следующие системные вызовы и библиотечные функции:
#no-indent[`raise`]
Посылает сигнал вызвавшему потоку.
#no-indent[`kill`]
Посылает сигнал указанному процессу, всем членам указанной группы процессов или всем процессам в системе.
#no-indent[`killpg`]
Посылает сигнал всем членам указанной группы процессов.
#no-indent[`pthread_kill`]
Посылает сигнал указанному потоку в том же процессе, что и вызывающий.
#no-indent[`tgkill`]
Посылает сигнал указанному потоку в указанном процессе (данный системный вызов используется в реализации `pthread_kill`).
#no-indent[`sigqueue`]
Посылает сигнал реального времени указанному процессу с сопроводительными данными.

= Ожидание сигнала для обработки
Следующие системные вызовы приостанавливают выполнение вызывающего процесса или нити до тех пор, пока не будет пойман сигнал (или необработанный сигнал не завершит процесс):
#no-indent[`pause`]
Приостанавливает выполнение до тех пор, пока не будет пойман любой сигнал.
#no-indent[`sigsuspend`]
Временно изменяет маску сигналов (смотрите далее) и приостанавливает выполнение до получения одного из незамаскированных сигналов.
= Синхронный приём сигнала
В отличие от асинхронного получения сигнала через обработчик, возможно синхронно получить сигнал, то есть блокировать выполнение до поступления сигнала в некоторой точке, в которой ядро вернёт информацию о сигнале вызывающему. Для этого существует два пути:
- С помощью `sigwaitinfo`, `sigtimedwait` и `sigwait`. Они приостанавливают выполнение до поступления одного из заданного набора сигналов. Каждый из этих вызовов возвращает информацию о полученном сигнале.
- С помощью `signalfd`. Данный вызов возвращает файловый дескриптор, который можно использовать для чтения информации о сигналах, доставляемых вызывающему. Каждое выполнение `read` с этим файловым дескриптором блокируется до тех пор, пока один из сигналов набора, указанного в вызове `signalfd`, не будет послан вызывающему. В возвращаемом `read` буфере содержится структура, описывающая сигнал.

= Исполнение обработчиков сигналов

Всякий раз, когда происходит переход из режима ядра в режим пользователя (например, при возврате из системного вызова или планировании выполнения потока на процессоре), ядро проверяет, есть ли ожидающий незаблокированный сигнал, для которого процесс установил обработчик сигнала. Если такой сигнал существует, выполняются следующие шаги:

+ Ядро выполняет необходимые подготовительные шаги для выполнения обработчика сигнала:

  + Сигнал удаляется из набора ожидающих сигналов.

  + Если обработчик сигнала был установлен вызовом `sigaction` с установленным флагом `SA_ONSTACK`, и поток определил альтернативный стек сигналов (с использованием `sigaltstack`), то этот стек устанавливается.

  + Различные части контекста, связанные с сигналом, сохраняются в специальном фрейме, созданном в стеке. Сохраненная информация включает в себя:

    - регистр счетчика программы (адрес следующей инструкции в основной программе, которая должна выполниться при возврате из обработчика сигнала);
    - архитектурно-специфичное состояние регистров, необходимое для возобновления прерванной программы;
    - текущую маску сигналов потока;
    - настройки альтернативного стека сигналов потока.
    (Если обработчик сигнала был установлен с использованием флага `SA_SIGINFO` в `sigaction`, то вышеуказанная информация доступна через объект `ucontext_t`, на который указывает третий аргумент обработчика сигнала.)
  + Любые сигналы, указанные в `act->sa_mask` при регистрации обработчика с использованием `sigprocmask`, добавляются в маску сигналов потока. Сигнал, который доставляется, также добавляется в маску сигналов, если при регистрации обработчика не указан флаг `SA_NODEFER`. Эти сигналы блокируются во время выполнения обработчика.

+ Ядро создает фрейм для обработчика сигнала в стеке. Устанавливается счетчик программы для потока, указывающий на первую инструкцию функции обработчика сигнала, и настраивается адрес возврата для этой функции, указывающий на участок кода пространства пользователя, называемый трамплин сигнала.

+ Ядро передает управление обратно в пространство пользователя, где начинается выполнение функции обработчика сигнала.

+ Когда обработчик сигнала возвращает управление, управление передается коду трамплина сигнала.

+ Трамплин сигнала вызывает `sigreturn` - системный вызов, который, используя информацию в созданном на шаге 1 стековом фрейме, восстанавливает состояние потока до того, как был вызван обработчик сигнала. Маска сигналов потока и настройки альтернативного стека сигналов восстанавливаются в рамках этой процедуры. По завершении вызова `sigreturn` ядро возвращает управление в пространство пользователя, и поток возобновляет выполнение с того момента, где его прервал обработчик сигнала.

#figure(
  image("assets/1.png"),
  caption: [Обработка сигнала],
)

Если обработчик сигнала не возвращает управление (например, управление передается из обработчика с использованием `siglongjmp` или обработчик выполняет новую программу с `execve`), то последний шаг не выполняется. В частности, в таких сценариях ответственность за восстановление состояния маски сигналов (с использованием `sigprocmask`) лежит на программисте. (Заметим, что `siglongjmp` восстанавливает маску сигналов в зависимости от значения `savesigs`, указанного в соответствующем вызове `sigsetjmp`)

С точки зрения ядра, выполнение кода обработчика сигнала точно такое же, как выполнение любого другого кода пространства пользователя. Другими словами, ядро не записывает никакой специальной информации о состоянии, указывающей, что поток в данный момент выполняет код обработчика сигнала. Все необходимые сведения о состоянии сохраняются в регистрах пространства пользователя и стеке пространства пользователя. Глубина, на которую могут быть вложены обработчики сигналов, ограничена только стеком пространства пользователя.

#bibliography("bib.yml", full: true)
