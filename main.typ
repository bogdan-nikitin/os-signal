#let indent = 2em
#let no-indent(body) = {
    set par(first-line-indent: 0em)
    [#body]
    set par(first-line-indent: indent)
}
#set text(lang: "ru")
#set page(numbering: "1")
#set par(
  first-line-indent: indent,
  justify: true,
)
#show par: set block(spacing: 0.65em)

= Сигналы в Linux
Никитин Богдан, M3236
= Введение

_Сигнал_ - это уведомление для процесса о том, что произошло событие. Сигналы иногда описываются как _программные прерывания_. Сигналы аналогичны аппаратным прерываниям в том смысле, что они прерывают нормальный ход выполнения программы, и в большинстве случаев невозможно точно предсказать, когда сигнал поступит.

Один процесс может (если у него есть подходящие разрешения) отправлять сигнал другому процессу. В этом случае сигналы могут использоваться в качестве техники синхронизации или даже как примитивной формы межпроцессного взаимодействия (IPC). Также возможно отправление процессом сигнала самому себе. Однако обычным источником многих сигналов, отправляемых процессу, является ядро. Среди типов событий, вызывающих генерацию ядром сигнала для процесса, могут быть следующие:

- Произошло аппаратное исключение, что означает, что аппаратное обеспечение зафиксировало неверное состояние и оповестила об этом ядро, которое в свою очередь отправило соответствующий сигнал затронутому процессу. Примерами аппаратного исключения могут быть выполнение ошибочной машинной инструкции, деление на 0 или обращение к недоступному участку памяти.

- Пользователь ввел один из специальных символов терминала, которые генерируют сигналы. К таким символам относятся символ _прерывания_ (обычно Control-C) и символ _приостановки_ (обычно Control-Z).

- Произошло программное событие. Например, появился ввод на файловом дескрипторе, изменен размер окна терминала, сработал таймер, превышено временное ограничение ЦП или завершился дочерний процесс.

Каждый сигнал определен как целое число. Фактические числа, используемые для каждого сигнала, различаются в различных реализациях, поэтому в программах используются соотвествующие константы с именами вида `SIGxxx`, определённые в `<signal.h>`. Например, когда пользователь вводит символ _прерывания_, сигнал `SIGINT` (номер сигнала 2) поступает в процесс.

Сигналы делятся на две большие категории. Первый набор составляют _традиционные_ или _стандартные_ сигналы, которые используются ядром для уведомления процессов о событиях. На Linux стандартные сигналы нумеруются от 1 до 31. Другой набор сигналов состоит из сигналов _реального времени_, которые будут описаны позже.

Ядро различает две разные фазы, связанные с передачей сигнала:

#no-indent[*Генерация сигнала*]

Ядро обновляет структуру данных процесса-получателя, чтобы отразить тот факт, что новый сигнал был отправлен.

#no-indent[*Доставка сигнала*]

Ядро заставляет процесс-получатель реагировать на сигнал, изменяя его состояние выполнения, начиная выполнение указанного обработчика сигнала или и того, и другого.

#v(1em)

Каждый сгенерированный сигнал может быть доставлен не более одного раза. Сигналы являются потребляемыми ресурсами: после их доставки отменяется вся информация о дескрипторе процесса, которая относится к их предыдущему существованию.

= Ожидающие сигналы и маска сигналов
Сигналы, которые были сгенерированы, но еще не доставлены, называются ожидающими сигналами. В любой момент времени для процесса может существовать только один ожидающий сигнал определенного типа; остальные ожидающие сигналы того же типа для того же процесса не ставятся в очередь, а просто отбрасываются. 

Обычно ожидающий сигнал доставляется процессу при следущем запланированном выполнении, или немедленно, если процесс уже выполняется (например, если процесс отправил сигнал сам себе). Однако иногда нам нужно гарантировать, что сегмент кода не будет прерван доставкой сигнала. Для этого мы можем добавить сигнал в маску сигналов процесса - набор сигналов, доставка которых в настоящее время заблокирована. Если сигнал генерируется во время блокировки, он остается в ожидании до тех пор, пока он не будет позже разблокирован (удален из маски сигналов). Различные системные вызовы позволяют процессу добавлять и удалять сигналы из своей маски сигналов.

= Диспозиция сигналов
После доставки сигнала процесс выполняет одно из следующих действий по умолчанию, в зависимости от сигнала:

Выполнение _действия по умолчанию_, связанного с сигналом. Это действие предопределено в ядре и зависит от типа сигнала и может быть одним из следующих:

#no-indent[*Term*]

Процесс завершается (убивается).

#no-indent[*Core*]

Процесс завершается (убивается), и, если возможно, создается файл ядра, содержащий его контекст выполнения; этот файл может использоваться в целях отладки.

#no-indent[*Ign*] 

Сигнал игнорируется.

#no-indent[*Stop*] 

Процесс останавливается

#no-indent[*Cont*] 

Если процесс был остановлен, его выполнение возобновляется

#v(1em)

Для каждого конкретного сигнала программа может изменить действие, выполняемое по его получении. Это называют установкой _диспозиции_ сигнала. Программа может установить одну из нижеперечисленных диспозиций сигнала.

- Должно произойти _действие по умолчанию_. Это применяется для отмены изменения настройки диспозиции сигнала.

- Сигнал _игнорируется_. Это полезно для сигнала, действие по умолчанию которого приведет к завершению процесса.

- Выполняется _обработчик сигнала_.

#bibliography("bib.yml", full: true)
